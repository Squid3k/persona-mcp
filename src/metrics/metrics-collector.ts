import {
  metrics,
  Meter,
  Counter,
  Histogram,
  UpDownCounter,
} from '@opentelemetry/api';
import {
  MeterProvider,
  PeriodicExportingMetricReader,
  AggregationTemporality,
} from '@opentelemetry/sdk-metrics';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-http';
import { Resource } from '@opentelemetry/resources';
import {
  SEMRESATTRS_SERVICE_NAME,
  SEMRESATTRS_SERVICE_VERSION,
} from '@opentelemetry/semantic-conventions';

export interface MetricsConfig {
  enabled?: boolean;
  endpoint?: string; // OTLP endpoint (default: http://localhost:4318/v1/metrics)
  headers?: Record<string, string>; // Optional headers for authentication
  interval?: number; // Export interval in milliseconds (default: 60000)
  serviceName?: string;
  serviceVersion?: string;
}

export class MetricsCollector {
  private meter: Meter;
  private meterProvider?: MeterProvider;
  private config: Required<MetricsConfig>;

  // HTTP metrics
  private httpRequestCounter!: Counter;
  private httpRequestDuration!: Histogram;
  private httpActiveConnections!: UpDownCounter;

  // MCP metrics
  private mcpRequestCounter!: Counter;
  private mcpRequestDuration!: Histogram;
  private mcpErrorCounter!: Counter;

  // Persona metrics
  private personaRequestCounter!: Counter;
  private personaPromptGenerationCounter!: Counter;
  private personaLoadDuration!: Histogram;

  // Tool metrics
  private toolInvocationCounter!: Counter;
  private toolExecutionDuration!: Histogram;
  private toolErrorCounter!: Counter;

  constructor(config: MetricsConfig = {}) {
    this.config = {
      enabled: config.enabled ?? true,
      endpoint: config.endpoint ?? 'http://localhost:4318/v1/metrics',
      headers: config.headers ?? {},
      interval: config.interval ?? 60000,
      serviceName: config.serviceName ?? 'personas-mcp',
      serviceVersion: config.serviceVersion ?? '1.0.0',
    };

    if (!this.config.enabled) {
      // Use no-op meter if metrics are disabled
      this.meter = metrics.getMeter('noop');
    } else {
      this.initializeMetrics();
      this.meter = metrics.getMeter(
        this.config.serviceName,
        this.config.serviceVersion
      );
    }

    this.createMetrics();
  }

  private initializeMetrics(): void {
    // Create resource with service information
    const resource = new Resource({
      [SEMRESATTRS_SERVICE_NAME]: this.config.serviceName,
      [SEMRESATTRS_SERVICE_VERSION]: this.config.serviceVersion,
    });

    // Create OTLP exporter
    const exporter = new OTLPMetricExporter({
      url: this.config.endpoint,
      headers: this.config.headers,
      temporalityPreference: AggregationTemporality.CUMULATIVE,
    });

    // Create meter provider with periodic exporting reader
    this.meterProvider = new MeterProvider({
      resource,
      readers: [
        new PeriodicExportingMetricReader({
          exporter,
          exportIntervalMillis: this.config.interval,
        }),
      ],
    });

    // Set global meter provider
    metrics.setGlobalMeterProvider(this.meterProvider);
  }

  private createMetrics(): void {
    // HTTP metrics
    this.httpRequestCounter = this.meter.createCounter('http_requests_total', {
      description: 'Total number of HTTP requests',
    });

    this.httpRequestDuration = this.meter.createHistogram(
      'http_request_duration_seconds',
      {
        description: 'HTTP request duration in seconds',
        unit: 's',
      }
    );

    this.httpActiveConnections = this.meter.createUpDownCounter(
      'http_active_connections',
      {
        description: 'Number of active HTTP connections',
      }
    );

    // MCP metrics
    this.mcpRequestCounter = this.meter.createCounter('mcp_requests_total', {
      description: 'Total number of MCP requests',
    });

    this.mcpRequestDuration = this.meter.createHistogram(
      'mcp_request_duration_seconds',
      {
        description: 'MCP request duration in seconds',
        unit: 's',
      }
    );

    this.mcpErrorCounter = this.meter.createCounter('mcp_errors_total', {
      description: 'Total number of MCP errors',
    });

    // Persona metrics
    this.personaRequestCounter = this.meter.createCounter(
      'persona_requests_total',
      {
        description: 'Total persona requests by ID',
      }
    );

    this.personaPromptGenerationCounter = this.meter.createCounter(
      'persona_prompt_generations_total',
      {
        description: 'Total prompts generated by persona',
      }
    );

    this.personaLoadDuration = this.meter.createHistogram(
      'persona_load_duration_seconds',
      {
        description: 'Persona load duration in seconds',
        unit: 's',
      }
    );

    // Tool metrics
    this.toolInvocationCounter = this.meter.createCounter(
      'tool_invocations_total',
      {
        description: 'Total tool invocations by name',
      }
    );

    this.toolExecutionDuration = this.meter.createHistogram(
      'tool_execution_duration_seconds',
      {
        description: 'Tool execution duration in seconds',
        unit: 's',
      }
    );

    this.toolErrorCounter = this.meter.createCounter('tool_errors_total', {
      description: 'Total tool errors by name',
    });
  }

  // HTTP metrics recording
  recordHttpRequest(
    method: string,
    endpoint: string,
    statusCode: number,
    duration: number
  ): void {
    const attributes = {
      method,
      endpoint,
      status_code: statusCode.toString(),
      status_class: `${Math.floor(statusCode / 100)}xx`,
    };

    this.httpRequestCounter.add(1, attributes);
    this.httpRequestDuration.record(duration / 1000, attributes); // Convert to seconds
  }

  incrementActiveConnections(): void {
    this.httpActiveConnections.add(1);
  }

  decrementActiveConnections(): void {
    this.httpActiveConnections.add(-1);
  }

  // MCP metrics recording
  recordMcpRequest(
    requestType: string,
    status: 'success' | 'error',
    duration: number
  ): void {
    const attributes = {
      type: requestType,
      status,
    };

    this.mcpRequestCounter.add(1, attributes);
    this.mcpRequestDuration.record(duration / 1000, attributes); // Convert to seconds

    if (status === 'error') {
      this.mcpErrorCounter.add(1, { type: requestType });
    }
  }

  // Persona metrics recording
  recordPersonaRequest(personaId: string): void {
    this.personaRequestCounter.add(1, { persona_id: personaId });
  }

  recordPersonaPromptGeneration(personaId: string): void {
    this.personaPromptGenerationCounter.add(1, { persona_id: personaId });
  }

  recordPersonaLoadDuration(duration: number): void {
    this.personaLoadDuration.record(duration / 1000); // Convert to seconds
  }

  // Tool metrics recording
  recordToolInvocation(toolName: string): void {
    this.toolInvocationCounter.add(1, { tool_name: toolName });
  }

  recordToolExecution(
    toolName: string,
    duration: number,
    success: boolean
  ): void {
    const attributes = { tool_name: toolName };

    this.toolExecutionDuration.record(duration / 1000, attributes); // Convert to seconds

    if (!success) {
      this.toolErrorCounter.add(1, attributes);
    }
  }

  // Graceful shutdown
  async shutdown(): Promise<void> {
    if (this.meterProvider) {
      await this.meterProvider.shutdown();
    }
  }
}

// Export a singleton instance that can be configured
export let metricsCollector: MetricsCollector;

export function initializeMetrics(config?: MetricsConfig): MetricsCollector {
  metricsCollector = new MetricsCollector(config);
  return metricsCollector;
}
